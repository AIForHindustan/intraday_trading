"""
AION Telegram Bot
Sends alerts and updates to Telegram channels
"""

import asyncio
import aiohttp
import json
import os
import logging
from typing import Dict, Optional

logger = logging.getLogger(__name__)

class AIONTelegramBot:
    def __init__(self):
        # Load from centralized config instead of environment variables
        import json
        from pathlib import Path
        
        config_path = Path(__file__).parent.parent / "alerts" / "config" / "telegram_config.json"
        try:
            with open(config_path, 'r') as f:
                self.config = json.load(f)
            self.bot_token = self.config.get('bot_token')
            self.main_channel = self.config.get('chat_ids', ['@NSEAlgoTrading'])[0]
            self.news_channel = self.config.get('chat_ids', ['@NSEAlgoTrading'])[0]
        except Exception as e:
            logger.error(f"Could not load Telegram config: {e}")
            self.config = {}
            self.bot_token = None
            self.main_channel = '@NSEAlgoTrading'
            self.news_channel = '@NSEAlgoTrading'
        
        if not self.bot_token:
            logger.warning("No bot token found in telegram_config.json")
        
        self.base_url = f"https://api.telegram.org/bot{self.bot_token}"
        
    async def send_message(self, message: str, chat_id: Optional[str] = None) -> bool:
        """Send message to Telegram channel"""
        if not self.bot_token:
            logger.error("No bot token configured")
            return False
            
        chat_id = chat_id or self.main_channel
        
        # Use signal bot token for private channels
        bot_token = self.bot_token
        if chat_id in ["-1003231444405", "1847390842"]:
            signal_bot_config = self.config.get('signal_bot', {})
            signal_token = signal_bot_config.get('bot_token')
            if signal_token:
                bot_token = signal_token
                base_url = f"https://api.telegram.org/bot{bot_token}"
            else:
                base_url = self.base_url
        else:
            base_url = self.base_url
        
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{base_url}/sendMessage"
                data = {
                    'chat_id': chat_id,
                    'text': message,
                    'parse_mode': 'Markdown'
                }
                
                async with session.post(url, data=data) as response:
                    if response.status == 200:
                        logger.info(f"Message sent to {chat_id}")
                        return True
                    else:
                        error_text = await response.text()
                        logger.error(f"Failed to send message: {response.status} - {error_text}")
                        return False
                        
        except Exception as e:
            logger.error(f"Error sending Telegram message: {e}")
            return False
    
    async def send_alert(self, alert_data: Dict) -> bool:
        """Send trading alert to Telegram"""
        try:
            symbol = alert_data.get('symbol', 'UNKNOWN')
            pattern = alert_data.get('pattern', 'unknown')
            signal = alert_data.get('signal', 'NEUTRAL')
            confidence = alert_data.get('confidence', 0.0)
            
            message = f"""
üö® <b>TRADING ALERT</b> üö®

<b>Symbol:</b> {symbol}
<b>Pattern:</b> {pattern}
<b>Signal:</b> {signal}
<b>Confidence:</b> {confidence:.0%}

<i>Generated by AION Algorithmic Trading System</i>
            """
            
            return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"Error sending alert: {e}")
            return False
    
    async def send_performance_update(self, performance_data: Dict) -> bool:
        """Send performance update to Telegram"""
        try:
            message = f"""
üìä <b>PERFORMANCE UPDATE</b> üìä

<b>Total Alerts:</b> {performance_data.get('total_alerts', 0)}
<b>Success Rate:</b> {performance_data.get('success_rate', 0):.1%}
<b>Average Return:</b> {performance_data.get('avg_return', 0):.2%}

<i>Performance data from AION Trading System</i>
            """
            
            return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"Error sending performance update: {e}")
            return False
    
    async def send_educational_content(self, content: Dict) -> bool:
        """Send educational content to Telegram"""
        try:
            title = content.get('title', 'Educational Content')
            description = content.get('description', 'Learn about algorithmic trading patterns')
            
            message = f"""
üìö <b>EDUCATIONAL CONTENT</b> üìö

<b>{title}</b>

{description}

<i>Educational content from AION Trading System</i>
            """
            
            return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"Error sending educational content: {e}")
            return False
    
    async def send_market_update(self, market_data: Dict) -> bool:
        """Send market update to Telegram"""
        try:
            message = f"""
üìà <b>MARKET UPDATE</b> üìà

<b>Market Status:</b> {market_data.get('status', 'Unknown')}
<b>Key Levels:</b> {market_data.get('key_levels', 'N/A')}

<i>Market update from AION Trading System</i>
            """
            
            return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"Error sending market update: {e}")
            return False
    
    async def send_validation_result(self, validation_data: Dict) -> bool:
        """Send validation result to Telegram channels with rolling windows data"""
        try:
            message = validation_data.get('message', '')
            symbol = validation_data.get('symbol', 'UNKNOWN')
            confidence = validation_data.get('confidence', 0.0)
            full_result = validation_data.get('full_result', {})
            
            # Use HTML parse mode for better formatting
            try:
                # Send to main channel with HTML formatting
                success = await self._send_message_html(message)
                
                # Also send to signal bot channels if it's a high-priority pattern
                pattern = full_result.get('validation_result', {}).get('pattern', '')
                if not pattern:
                    pattern = full_result.get('alert_type', '')
                
                high_priority_patterns = ['kow_signal_straddle', 'reversal', 'volume_breakout']
                if any(p in pattern.lower() for p in high_priority_patterns):
                    # Send to all signal bot channels
                    signal_bot_config = self.config.get('signal_bot', {})
                    signal_channels = signal_bot_config.get('chat_ids', [])
                    for channel in signal_channels:
                        await self._send_message_html(message, channel)
                    logger.info(f"üì° Validation result sent to {len(signal_channels)} signal bot channels: {symbol}")
                
                if success:
                    logger.info(f"üì° Validation result sent to Telegram: {symbol} ({confidence:.1%})")
                
                return success
            except Exception:
                # Fallback to regular send
                return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"Error sending validation result: {e}")
            return False
    
    async def _send_message_html(self, message: str, chat_id: Optional[str] = None) -> bool:
        """Send message with HTML formatting"""
        if not self.bot_token:
            logger.error("No bot token configured")
            return False
            
        chat_id = chat_id or self.main_channel
        
        # Use signal bot token for private channels
        bot_token = self.bot_token
        if chat_id in ["-1003231444405", "1847390842"]:
            signal_bot_config = self.config.get('signal_bot', {})
            signal_token = signal_bot_config.get('bot_token')
            if signal_token:
                bot_token = signal_token
                base_url = f"https://api.telegram.org/bot{bot_token}"
            else:
                base_url = self.base_url
        else:
            base_url = self.base_url
        
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{base_url}/sendMessage"
                data = {
                    'chat_id': chat_id,
                    'text': message,
                    'parse_mode': 'HTML'  # Use HTML instead of Markdown
                }
                
                async with session.post(url, data=data) as response:
                    if response.status == 200:
                        logger.info(f"Message sent to {chat_id}")
                        return True
                    else:
                        error_text = await response.text()
                        logger.error(f"Failed to send message: {response.status} - {error_text}")
                        return False
                        
        except Exception as e:
            logger.error(f"Error sending Telegram message: {e}")
            return False
    
    async def run_bot(self):
        """Run the Telegram bot (placeholder for webhook/polling)"""
        logger.info("Telegram bot started")
        # This would typically run webhook or polling
        # For now, just keep the bot alive
        while True:
            await asyncio.sleep(60)

# Standalone function to send maintenance message
async def send_maintenance_message():
    """Send maintenance message to Telegram"""
    bot = AIONTelegramBot()
    
    message = """
üöß <b>SYSTEM MAINTENANCE NOTICE</b> üöß

We are extremely sorry for 2 days we are implementing a few changes to make the system automated and robust so please bear with us. 

<b>‚ö†Ô∏è IMPORTANT:</b> Do not trade on signals generated as we are trying out experimentations on the historical models we have created. 

Apologies for any inconvenience caused.

<i>Thank you for your patience during this maintenance period.</i>
    """
    
    success = await bot.send_message(message)
    if success:
        print("‚úÖ Maintenance message sent to Telegram")
    else:
        print("‚ùå Failed to send maintenance message")
    
    return success

if __name__ == "__main__":
    # Send maintenance message
    asyncio.run(send_maintenance_message())
