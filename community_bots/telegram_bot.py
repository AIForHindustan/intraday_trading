"""
AION Telegram Bot
Sends alerts and updates to Telegram channels
"""

import asyncio
import aiohttp
import json
import os
import logging
from typing import Dict, Optional, List

logger = logging.getLogger(__name__)

class AIONTelegramBot:
    def __init__(self):
        # Load from centralized config instead of environment variables
        import json
        from pathlib import Path
        
        config_path = Path(__file__).parent.parent / "alerts" / "config" / "telegram_config.json"
        try:
            with open(config_path, 'r') as f:
                self.config = json.load(f)
            self.bot_token = self.config.get('bot_token')
            self.main_channel = self.config.get('chat_ids', ['@NSEAlgoTrading'])[0]
            self.news_channel = self.config.get('chat_ids', ['@NSEAlgoTrading'])[0]
        except Exception as e:
            logger.error(f"Could not load Telegram config: {e}")
            self.config = {}
            self.bot_token = None
            self.main_channel = '@NSEAlgoTrading'
            self.news_channel = '@NSEAlgoTrading'
        
        if not self.bot_token:
            logger.warning("No bot token found in telegram_config.json")
        
        self.base_url = f"https://api.telegram.org/bot{self.bot_token}"
        
    async def send_message(self, message: str, chat_id: Optional[str] = None) -> bool:
        """Send message to Telegram channel"""
        if not self.bot_token:
            logger.error("No bot token configured")
            return False
            
        chat_id = chat_id or self.main_channel
        
        # Use signal bot token for private channels
        bot_token = self.bot_token
        if chat_id in ["-1003231444405", "1847390842"]:
            signal_bot_config = self.config.get('signal_bot', {})
            signal_token = signal_bot_config.get('bot_token')
            if signal_token:
                bot_token = signal_token
                base_url = f"https://api.telegram.org/bot{bot_token}"
            else:
                base_url = self.base_url
        else:
            base_url = self.base_url
        
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{base_url}/sendMessage"
                data = {
                    'chat_id': chat_id,
                    'text': message,
                    'parse_mode': None  # Plain text mode (no HTML/Markdown parsing)
                }
                
                async with session.post(url, data=data) as response:
                    if response.status == 200:
                        logger.info(f"Message sent to {chat_id}")
                        return True
                    else:
                        error_text = await response.text()
                        logger.error(f"Failed to send message: {response.status} - {error_text}")
                        return False
                        
        except Exception as e:
            logger.error(f"Error sending Telegram message: {e}")
            return False
    
    async def send_alert(self, alert_data: Dict) -> bool:
        """Send trading alert to Telegram"""
        try:
            symbol = alert_data.get('symbol', 'UNKNOWN')
            pattern = alert_data.get('pattern', 'unknown')
            signal = alert_data.get('signal', 'NEUTRAL')
            confidence = alert_data.get('confidence', 0.0)
            
            message = f"""
üö® <b>TRADING ALERT</b> üö®

<b>Symbol:</b> {symbol}
<b>Pattern:</b> {pattern}
<b>Signal:</b> {signal}
<b>Confidence:</b> {confidence:.0%}

<i>Generated by AION Algorithmic Trading System</i>
            """
            
            return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"Error sending alert: {e}")
            return False
    
    async def send_performance_update(self, performance_data: Dict) -> bool:
        """Send performance update to Telegram"""
        try:
            message = f"""
üìä <b>PERFORMANCE UPDATE</b> üìä

<b>Total Alerts:</b> {performance_data.get('total_alerts', 0)}
<b>Success Rate:</b> {performance_data.get('success_rate', 0):.1%}
<b>Average Return:</b> {performance_data.get('avg_return', 0):.2%}

<i>Performance data from AION Trading System</i>
            """
            
            return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"Error sending performance update: {e}")
            return False
    
    async def send_educational_content(self, content: Dict, send_to_all_channels: bool = True) -> bool:
        """Send educational content to Telegram - sends to main channel and signal bot channels"""
        try:
            title = content.get('title', 'Educational Content')
            full_content = content.get('content', content.get('description', ''))
            
            # Telegram has a 4096 character limit per message
            # Split into multiple messages if needed
            max_length = 4000  # Leave buffer for HTML tags
            
            # Prepare messages
            if len(full_content) <= max_length:
                # Single message
                message = self._markdown_to_html(full_content)
                messages = [message]
            else:
                # Multiple messages
                header = f"üìö {title} üìö\n\n"
                messages = [header]
                
                # Split content into chunks
                chunks = self._split_content(full_content, max_length)
                for i, chunk in enumerate(chunks, 1):
                    chunk_text = self._markdown_to_html(chunk)
                    if i < len(chunks):
                        chunk_text += f"\n\n(Part {i} of {len(chunks)})"
                    else:
                        chunk_text += f"\n\nEducational content from AION Trading System"
                    messages.append(chunk_text)
            
            # Determine which channels to send to
            channels_to_send = [self.main_channel]
            
            # Also send to signal bot channels for educational content (especially Kow Signal)
            if send_to_all_channels:
                signal_bot_config = self.config.get('signal_bot', {})
                signal_channels = signal_bot_config.get('chat_ids', [])
                if signal_channels:
                    channels_to_send.extend(signal_channels)
                    logger.info(f"üìö Sending educational content to {len(channels_to_send)} channels: main + {len(signal_channels)} signal bot channels")
            
            # Send to all channels
            overall_success = True
            for channel in channels_to_send:
                channel_success = True
                for i, message_text in enumerate(messages):
                    success = await self.send_message(message_text, chat_id=channel)
                    if not success:
                        channel_success = False
                        overall_success = False
                    # Small delay between messages
                    if i < len(messages) - 1:
                        await asyncio.sleep(1)
                
                if channel_success:
                    logger.info(f"‚úÖ Educational content sent to {channel}")
                else:
                    logger.warning(f"‚ö†Ô∏è Failed to send some messages to {channel}")
            
            return overall_success
            
        except Exception as e:
            logger.error(f"Error sending educational content: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False
    
    def _markdown_to_html(self, text: str) -> str:
        """Convert markdown to HTML for Telegram - plain text version (no HTML tags)"""
        # User requested no HTML formatting, just clean text
        # Remove all markdown markers
        text = text.replace('**', '')  # Remove bold markers
        text = text.replace('*', '')   # Remove italic markers  
        text = text.replace('#', '')    # Remove heading markers
        
        # Clean up any empty HTML tags that might exist
        import re
        text = re.sub(r'<[^>]*>', '', text)  # Remove any HTML tags
        
        # Return plain text
        return text
    
    def _split_content(self, content: str, max_length: int) -> List[str]:
        """Split content into chunks respecting line breaks"""
        chunks = []
        current_chunk = []
        current_length = 0
        
        paragraphs = content.split('\n\n')
        
        for paragraph in paragraphs:
            para_length = len(paragraph) + 2  # +2 for \n\n
            
            if current_length + para_length > max_length:
                if current_chunk:
                    chunks.append('\n\n'.join(current_chunk))
                    current_chunk = [paragraph]
                    current_length = para_length
                else:
                    # Single paragraph is too long, split by sentences
                    sentences = paragraph.split('. ')
                    for sentence in sentences:
                        sent_length = len(sentence) + 2
                        if current_length + sent_length > max_length:
                            if current_chunk:
                                chunks.append('\n\n'.join(current_chunk))
                                current_chunk = []
                                current_length = 0
                            chunks.append(sentence)
                        else:
                            current_chunk.append(sentence)
                            current_length += sent_length
            else:
                current_chunk.append(paragraph)
                current_length += para_length
        
        if current_chunk:
            chunks.append('\n\n'.join(current_chunk))
        
        return chunks
    
    async def send_market_update(self, market_data: Dict) -> bool:
        """Send market update to Telegram"""
        try:
            message = f"""
üìà <b>MARKET UPDATE</b> üìà

<b>Market Status:</b> {market_data.get('status', 'Unknown')}
<b>Key Levels:</b> {market_data.get('key_levels', 'N/A')}

<i>Market update from AION Trading System</i>
            """
            
            return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"Error sending market update: {e}")
            return False
    
    async def send_validation_result(self, validation_data: Dict) -> bool:
        """Send validation result to Telegram channels with rolling windows data"""
        try:
            message = validation_data.get('message', '')
            symbol = validation_data.get('symbol', 'UNKNOWN')
            confidence = validation_data.get('confidence', 0.0)
            full_result = validation_data.get('full_result', {})
            
            # Use HTML parse mode for better formatting
            try:
                # Send to main channel with HTML formatting
                success = await self._send_message_html(message)
                
                # Also send to signal bot channels if it's a high-priority pattern
                pattern = full_result.get('validation_result', {}).get('pattern', '')
                if not pattern:
                    pattern = full_result.get('alert_type', '')
                
                high_priority_patterns = ['kow_signal_straddle', 'reversal', 'volume_breakout']
                if any(p in pattern.lower() for p in high_priority_patterns):
                    # Send to all signal bot channels
                    signal_bot_config = self.config.get('signal_bot', {})
                    signal_channels = signal_bot_config.get('chat_ids', [])
                    for channel in signal_channels:
                        await self._send_message_html(message, channel)
                    logger.info(f"üì° Validation result sent to {len(signal_channels)} signal bot channels: {symbol}")
                
                if success:
                    logger.info(f"üì° Validation result sent to Telegram: {symbol} ({confidence:.1%})")
                
                return success
            except Exception:
                # Fallback to regular send
                return await self.send_message(message)
            
        except Exception as e:
            logger.error(f"Error sending validation result: {e}")
            return False
    
    async def _send_message_html(self, message: str, chat_id: Optional[str] = None) -> bool:
        """Send message with HTML formatting"""
        if not self.bot_token:
            logger.error("No bot token configured")
            return False
            
        chat_id = chat_id or self.main_channel
        
        # Use signal bot token for private channels
        bot_token = self.bot_token
        if chat_id in ["-1003231444405", "1847390842"]:
            signal_bot_config = self.config.get('signal_bot', {})
            signal_token = signal_bot_config.get('bot_token')
            if signal_token:
                bot_token = signal_token
                base_url = f"https://api.telegram.org/bot{bot_token}"
            else:
                base_url = self.base_url
        else:
            base_url = self.base_url
        
        try:
            async with aiohttp.ClientSession() as session:
                url = f"{base_url}/sendMessage"
                data = {
                    'chat_id': chat_id,
                    'text': message,
                    'parse_mode': 'HTML'  # Use HTML instead of Markdown
                }
                
                async with session.post(url, data=data) as response:
                    if response.status == 200:
                        logger.info(f"Message sent to {chat_id}")
                        return True
                    else:
                        error_text = await response.text()
                        logger.error(f"Failed to send message: {response.status} - {error_text}")
                        return False
                        
        except Exception as e:
            logger.error(f"Error sending Telegram message: {e}")
            return False
    
    async def run_bot(self):
        """Run the Telegram bot (placeholder for webhook/polling)"""
        logger.info("Telegram bot started")
        # This would typically run webhook or polling
        # For now, just keep the bot alive
        while True:
            await asyncio.sleep(60)

# Standalone function to send maintenance message
async def send_maintenance_message():
    """Send maintenance message to Telegram"""
    bot = AIONTelegramBot()
    
    message = """
üöß <b>SYSTEM MAINTENANCE NOTICE</b> üöß

We are extremely sorry for 2 days we are implementing a few changes to make the system automated and robust so please bear with us. 

<b>‚ö†Ô∏è IMPORTANT:</b> Do not trade on signals generated as we are trying out experimentations on the historical models we have created. 

Apologies for any inconvenience caused.

<i>Thank you for your patience during this maintenance period.</i>
    """
    
    success = await bot.send_message(message)
    if success:
        print("‚úÖ Maintenance message sent to Telegram")
    else:
        print("‚ùå Failed to send maintenance message")
    
    return success

if __name__ == "__main__":
    # Send maintenance message
    asyncio.run(send_maintenance_message())
