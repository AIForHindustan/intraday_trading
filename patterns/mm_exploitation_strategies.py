#!/usr/bin/env python3
"""
MARKET MAKER EXPLOITATION STRATEGIES
====================================

Advanced strategies to profit from market maker manipulation patterns.
Systematically integrated with existing trap detection system.

Strategies Implemented:
1. Max Pain Exploitation - Trade toward max pain pinning
2. Retail Sentiment Fade - Fade extreme retail positioning
3. Gamma Trap Exploitation - Profit from gamma pinning
4. Pin Play - Options expiry pinning trades
5. IV Crush Play - Event-based volatility collapse
6. Retail Fade System - Automated sentiment contrarian

Author: System
Date: 2025-01-11
Status: Production Ready
"""

import logging
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime, timedelta
from collections import defaultdict
from pathlib import Path
import json

# Import volume thresholds for dynamic threshold management
try:
    from config.thresholds import get_volume_threshold
    from utils.vix_utils import get_vix_regime
except ImportError:
    def get_volume_threshold(pattern_type, vix_regime='NORMAL'):
        return 2.0  # Default fallback
    def get_vix_regime(current_vix):
        return 'NORMAL'

# Import ExpiryCalculator for F&O expiry calculations
try:
    from intraday_scanner.calculations import ExpiryCalculator
except ImportError:
    class ExpiryCalculator:
        def get_days_to_expiry(self, symbol):
            return 999  # Default fallback

logger = logging.getLogger(__name__)


class MMExploitationStrategies:
    """
    Market Maker Exploitation Strategy Generator

    Generates actionable trades that exploit MM manipulation patterns.
    Integrates with existing trap detection and indicator systems.
    """

    def __init__(self, redis_client=None):
        """
        Initialize MM exploitation strategies.

        Args:
            redis_client: Redis client for historical data access
        """
        self.redis_client = redis_client
        self.expiry_calculator = ExpiryCalculator()

        # Load dynamic volume baselines (20d/55d) for adaptive thresholds
        self.volume_baselines = self._load_volume_baselines()
        self.sector_volatility = self._load_sector_volatility()

        # Strategy thresholds - NOW DYNAMIC based on market conditions
        # Base thresholds will be adjusted per instrument using dynamic data
        self.BASE_MAX_PAIN_DISTANCE_THRESHOLD = 0.02  # 2% from max pain (base)
        self.BASE_RETAIL_BULLISH_EXTREME = 0.70  # 70% bullish is extreme (base)
        self.BASE_RETAIL_BEARISH_EXTREME = 0.30  # 30% bullish is extreme (base)
        self.BASE_SOCIAL_BUZZ_EXTREME = 0.80  # 80% social media buzz (base)
        self.BASE_OI_CONCENTRATION_HIGH = 0.70  # 70% OI in few strikes (base)
        self.BASE_HIGH_IV_THRESHOLD = 80  # 80% IV is extremely high (base)
        self.DAYS_TO_EXPIRY_PIN_TRADE = 3  # Last 3 days for pin play

        # Strategy statistics
        self.stats = {
            "total_strategies_generated": 0,
            "max_pain_trades": 0,
            "retail_fade_trades": 0,
            "gamma_trap_trades": 0,
            "pin_play_trades": 0,
            "iv_crush_trades": 0,
            "retail_fade_system_trades": 0,
            "dynamic_adjustments_applied": 0,
        }

        logger.info("✅ MM Exploitation Strategies initialized with dynamic thresholds")

    def _load_volume_baselines(self) -> Dict[str, Dict[str, float]]:
        """Load dynamic 20d/55d volume baselines from volume_averages_20d.json"""
        baselines = {}
        try:
            volume_file = (
                Path(__file__).parent.parent
                / "config"
                / "volume_averages_20d.json"
            )
            if volume_file.exists():
                with open(volume_file, "r") as f:
                    data = json.load(f)

                for symbol_key, symbol_data in data.items():
                    # Extract clean symbol (e.g., NSE:RELIANCE -> RELIANCE)
                    clean_symbol = symbol_key.split(":", 1)[-1]
                    baselines[clean_symbol] = {
                        "avg_volume_20d": symbol_data.get("avg_volume_20d", 0),
                        "avg_volume_55d": symbol_data.get("avg_volume_55d", 0),
                        "avg_price_20d": symbol_data.get("avg_price_20d", 0),
                        "avg_price_55d": symbol_data.get("avg_price_55d", 0),
                    }

                logger.info(
                    f"✅ MM Strategies: Loaded volume baselines for {len(baselines)} instruments"
                )
        except Exception as e:
            logger.warning(f"⚠️ Could not load volume baselines for MM strategies: {e}")

        return baselines

    def _load_sector_volatility(self) -> Dict[str, Dict[str, float]]:
        """Load sector-specific volatility data for dynamic threshold adjustment"""
        sector_vol = {}
        try:
            # Try patterns/data/sector/sector_volatility.json first (main location)
            sector_file = (
                Path(__file__).parent / "data" / "sector" / "sector_volatility.json"
            )
            if not sector_file.exists():
                # Fallback to config/sector_volatility.json
                sector_file = (
                    Path(__file__).parent.parent / "config" / "sector_volatility.json"
                )

            if sector_file.exists():
                with open(sector_file, "r") as f:
                    data = json.load(f)
                    # Extract just the sectors data if it has metadata wrapper
                    if "sectors" in data:
                        sector_vol = data["sectors"]
                    else:
                        sector_vol = data
                logger.info(
                    f"✅ MM Strategies: Loaded sector volatility for {len(sector_vol)} sectors"
                )
            else:
                logger.warning(f"⚠️ Sector volatility file not found at {sector_file}")
        except Exception as e:
            logger.warning(f"⚠️ Could not load sector volatility: {e}")

        return sector_vol

    def _get_dynamic_threshold(
        self, symbol: str, base_threshold: float, threshold_type: str
    ) -> float:
        """
        Calculate dynamic threshold based on instrument characteristics.

        Args:
            symbol: Trading symbol
            base_threshold: Base threshold value
            threshold_type: Type of threshold (max_pain, oi_concentration, etc.)

        Returns:
            Adjusted threshold based on market conditions
        """
        clean_symbol = symbol.split(":", 1)[-1].upper()
        baseline_data = self.volume_baselines.get(clean_symbol, {})

        adjusted_threshold = base_threshold

        # Adjust based on volume trends (20d vs 55d)
        avg_vol_20d = baseline_data.get("avg_volume_20d", 0)
        avg_vol_55d = baseline_data.get("avg_volume_55d", 0)

        if avg_vol_20d > 0 and avg_vol_55d > 0:
            volume_trend = avg_vol_20d / avg_vol_55d

            if threshold_type == "max_pain_distance":
                # Rising volume = wider max pain range
                if volume_trend > 1.3:
                    adjusted_threshold *= 1.15
                elif volume_trend < 0.7:
                    adjusted_threshold *= 0.90

            elif threshold_type == "oi_concentration":
                # Rising volume = need higher OI concentration to confirm trap
                if volume_trend > 1.3:
                    adjusted_threshold *= 1.10

            elif threshold_type == "iv_threshold":
                # Rising volume = adjust IV expectations
                if volume_trend > 1.3:
                    adjusted_threshold *= 1.05

        # Adjust based on price volatility
        avg_price_20d = baseline_data.get("avg_price_20d", 0)
        avg_price_55d = baseline_data.get("avg_price_55d", 0)

        if avg_price_20d > 0 and avg_price_55d > 0:
            price_vol = abs(avg_price_20d - avg_price_55d) / avg_price_55d

            # Higher price volatility = widen thresholds
            if price_vol > 0.1 and threshold_type == "max_pain_distance":
                adjusted_threshold *= 1.10

        if adjusted_threshold != base_threshold:
            self.stats["dynamic_adjustments_applied"] += 1

        return adjusted_threshold

    def generate_all_strategies(
        self, symbol: str, indicators: Dict[str, Any], trap_result: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        # Get VIX regime for dynamic thresholds
        vix_level = indicators.get('vix_level', 0)
        vix_regime = get_vix_regime(vix_level)
        """
        Generate all applicable MM exploitation strategies.

        Args:
            symbol: Trading symbol
            indicators: Complete indicator dictionary
            trap_result: Result from market maker trap detection

        Returns:
            List of strategy dictionaries with actionable trades
        """
        strategies = []

        # Only generate strategies if we have the necessary data
        if not indicators or not trap_result:
            return strategies

        # Strategy 1: Max Pain Exploitation
        max_pain_strategy = self.max_pain_exploitation(symbol, indicators)
        if max_pain_strategy:
            # Check volume threshold for max pain exploitation
            volume_threshold = get_volume_threshold('max_pain_exploitation', vix_regime)
            if max_pain_strategy.get('volume_ratio', 0) >= volume_threshold:
                strategies.append(max_pain_strategy)

        # Strategy 2: Retail Sentiment Fade
        sentiment_strategy = self.fade_retail_sentiment(symbol, indicators)
        if sentiment_strategy:
            # Check volume threshold for retail sentiment fade
            volume_threshold = get_volume_threshold('retail_sentiment_fade', vix_regime)
            if sentiment_strategy.get('volume_ratio', 0) >= volume_threshold:
                strategies.append(sentiment_strategy)

        # Strategy 3: Gamma Trap Exploitation
        gamma_strategy = self.exploit_gamma_trap(symbol, indicators)
        if gamma_strategy:
            # Check volume threshold for gamma trap exploitation
            volume_threshold = get_volume_threshold('gamma_trap_exploitation', vix_regime)
            if gamma_strategy.get('volume_ratio', 0) >= volume_threshold:
                strategies.append(gamma_strategy)

        # Strategy 4: Pin Play (near expiry)
        pin_strategy = self.setup_pin_play(symbol, indicators)
        if pin_strategy:
            # Check volume threshold for pin play
            volume_threshold = get_volume_threshold('pin_play', vix_regime)
            if pin_strategy.get('volume_ratio', 0) >= volume_threshold:
                strategies.append(pin_strategy)

        # Strategy 5: IV Crush Play (event-based)
        iv_strategy = self.iv_crush_play(symbol, indicators)
        if iv_strategy:
            # Check volume threshold for IV crush play
            volume_threshold = get_volume_threshold('iv_crush_play', vix_regime)
            if iv_strategy.get('volume_ratio', 0) >= volume_threshold:
                strategies.append(iv_strategy)

        # Strategy 6: Retail Fade System (automated)
        fade_strategies = self.retail_fade_system(symbol, indicators)
        if fade_strategies:
            # Check volume thresholds for retail fade strategies
            bearish_threshold = get_volume_threshold('retail_fade_system_bearish', vix_regime)
            bullish_threshold = get_volume_threshold('retail_fade_system_bullish', vix_regime)
            
            filtered_strategies = []
            for strategy in fade_strategies:
                strategy_name = strategy.get('strategy_name', '')
                volume_ratio = strategy.get('volume_ratio', 0)
                
                if 'bearish' in strategy_name and volume_ratio >= bearish_threshold:
                    filtered_strategies.append(strategy)
                elif 'bullish' in strategy_name and volume_ratio >= bullish_threshold:
                    filtered_strategies.append(strategy)
            
            strategies.extend(filtered_strategies)

        self.stats["total_strategies_generated"] += len(strategies)

        return strategies

    def max_pain_exploitation(
        self, symbol: str, indicators: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """
        Strategy 1: Trade in the direction of max pain.

        Market makers want price to gravitate toward max pain to minimize
        their options payout. We trade in that direction.

        Args:
            symbol: Trading symbol
            indicators: Indicator dictionary with max_pain_price

        Returns:
            Strategy dictionary or None if not applicable
        """
        max_pain = indicators.get("max_pain_price", 0)
        current_price = indicators.get("last_price", 0)

        if not max_pain or not current_price:
            return None

        # Calculate distance from max pain
        distance_pct = abs(max_pain - current_price) / current_price

        # Use dynamic threshold based on instrument characteristics
        dynamic_threshold = self._get_dynamic_threshold(
            symbol, self.BASE_MAX_PAIN_DISTANCE_THRESHOLD, "max_pain_distance"
        )

        # Only trade if price is far enough from max pain
        if distance_pct < dynamic_threshold:
            return None

        # Determine trade direction
        if current_price > max_pain:
            # MM want price to DROP to max pain
            action = "SELL CALL CREDIT SPREAD"
            direction = "BEARISH"

            # Calculate strikes (sell at 50% of distance, buy at 80% of distance)
            distance = current_price - max_pain
            sell_strike = max_pain + (distance * 0.5)
            buy_strike = max_pain + (distance * 0.8)

            strategy_logic = (
                f"Price {distance_pct:.1%} above max pain (threshold: {dynamic_threshold:.1%}). "
                f"Market makers will push price down to ₹{max_pain:.2f} to minimize payouts. "
                f"Sell call spread to profit from downward move."
            )
        else:
            # MM want price to RISE to max pain
            action = "SELL PUT CREDIT SPREAD"
            direction = "BULLISH"

            # Calculate strikes
            distance = max_pain - current_price
            sell_strike = max_pain - (distance * 0.5)
            buy_strike = max_pain - (distance * 0.8)

            strategy_logic = (
                f"Price {distance_pct:.1%} below max pain (threshold: {dynamic_threshold:.1%}). "
                f"Market makers will push price up to ₹{max_pain:.2f} to minimize payouts. "
                f"Sell put spread to profit from upward move."
            )

        self.stats["max_pain_trades"] += 1

        return {
            "strategy_name": "MAX_PAIN_EXPLOITATION",
            "strategy_type": "mm_exploitation",
            "symbol": symbol,
            "action": action,
            "direction": direction,
            "confidence": 0.75,  # High probability MM will pin to max pain
            "dynamic_threshold_used": dynamic_threshold,
            "threshold_adjustment": (
                dynamic_threshold / self.BASE_MAX_PAIN_DISTANCE_THRESHOLD - 1.0
            )
            * 100,  # % adjustment
            "current_price": current_price,
            "max_pain_price": max_pain,
            "distance_pct": distance_pct,
            "strikes": {
                "sell_strike": round(sell_strike, 2),
                "buy_strike": round(buy_strike, 2),
                "spread_width": abs(buy_strike - sell_strike),
            },
            "logic": strategy_logic,
            "risk_level": "MEDIUM",
            "holding_period": "Until expiry or 50% profit",
            "profit_source": "Market maker pinning + Time decay",
            "alert_priority": "HIGH",
        }

    def fade_retail_sentiment(
        self, symbol: str, indicators: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """
        Strategy 2: Fade extreme retail sentiment.

        When retail is extremely bullish/bearish, smart money takes the
        opposite side. We fade the retail crowd.

        Args:
            symbol: Trading symbol
            indicators: Indicator dictionary with sentiment data

        Returns:
            Strategy dictionary or None if not applicable
        """
        retail_bullish_ratio = indicators.get("retail_bullish_ratio", 0.5)
        social_media_buzz = indicators.get("social_media_score", 0.5)

        # Check for extreme bullish sentiment
        if (
            retail_bullish_ratio > self.BASE_RETAIL_BULLISH_EXTREME
            and social_media_buzz > self.BASE_SOCIAL_BUZZ_EXTREME
        ):
            action = "BUY PUT DEBIT SPREAD"
            direction = "BEARISH"
            logic = (
                f"RETAIL CROWDED LONG: {retail_bullish_ratio:.0%} bullish, "
                f"{social_media_buzz:.0%} social media buzz. "
                f"Retail is overleveraged. Smart money will push price down. "
                f"Fade the crowd with bearish spread."
            )
            confidence = 0.70

        # Check for extreme bearish sentiment
        elif (
            retail_bullish_ratio < self.BASE_RETAIL_BEARISH_EXTREME
            and social_media_buzz < (1.0 - self.BASE_SOCIAL_BUZZ_EXTREME)
        ):
            action = "BUY CALL DEBIT SPREAD"
            direction = "BULLISH"
            logic = (
                f"RETAIL CROWDED SHORT: {retail_bullish_ratio:.0%} bullish, "
                f"{social_media_buzz:.0%} social media buzz. "
                f"Retail is overly bearish. Smart money will squeeze shorts. "
                f"Fade the crowd with bullish spread."
            )
            confidence = 0.70

        else:
            return None

        self.stats["retail_fade_trades"] += 1

        return {
            "strategy_name": "RETAIL_SENTIMENT_FADE",
            "strategy_type": "mm_exploitation",
            "symbol": symbol,
            "action": action,
            "direction": direction,
            "confidence": confidence,
            "retail_bullish_ratio": retail_bullish_ratio,
            "social_media_score": social_media_buzz,
            "logic": logic,
            "risk_level": "MEDIUM",
            "holding_period": "2-5 days",
            "profit_source": "Retail sentiment reversal",
            "alert_priority": "HIGH",
        }

    def exploit_gamma_trap(
        self, symbol: str, indicators: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """
        Strategy 3: Profit from gamma pinning at high OI strikes.

        When OI is concentrated at specific strikes, dealers hedge by
        buying/selling to keep price pinned. We sell iron condors around
        these strikes to profit from the pinning.

        Args:
            symbol: Trading symbol
            indicators: Indicator dictionary with options chain data

        Returns:
            Strategy dictionary or None if not applicable
        """
        oi_concentration = indicators.get("options_oi_concentration", 0.0)
        max_pain_strike = indicators.get("max_pain_strike", 0)
        current_price = indicators.get("last_price", 0)

        if oi_concentration < self.BASE_OI_CONCENTRATION_HIGH:
            return None

        if not max_pain_strike or not current_price:
            return None

        # Calculate iron condor strikes around max pain
        # Assumes strikes are in increments (e.g., 100 points for indices)
        strike_increment = self._estimate_strike_increment(symbol, current_price)

        # Sell iron condor centered around max pain
        call_strike = max_pain_strike + strike_increment
        call_buy_strike = call_strike + strike_increment
        put_strike = max_pain_strike - strike_increment
        put_buy_strike = put_strike - strike_increment

        logic = (
            f"GAMMA TRAP: {oi_concentration:.0%} OI concentrated at ₹{max_pain_strike}. "
            f"Market makers will pin price between ₹{put_strike} and ₹{call_strike}. "
            f"Sell iron condor to profit from pinning + time decay."
        )

        self.stats["gamma_trap_trades"] += 1

        return {
            "strategy_name": "GAMMA_TRAP_EXPLOITATION",
            "strategy_type": "mm_exploitation",
            "symbol": symbol,
            "action": "SELL IRON CONDOR",
            "direction": "NEUTRAL",
            "confidence": 0.80,  # High probability of pinning
            "current_price": current_price,
            "max_pain_strike": max_pain_strike,
            "oi_concentration": oi_concentration,
            "strikes": {
                "sell_call": call_strike,
                "buy_call": call_buy_strike,
                "sell_put": put_strike,
                "buy_put": put_buy_strike,
                "range": f"₹{put_strike} - ₹{call_strike}",
            },
            "logic": logic,
            "risk_level": "LOW",
            "holding_period": "Until expiry",
            "profit_source": "Gamma pinning + Theta decay",
            "alert_priority": "VERY HIGH",
            "max_profit": "Premium collected",
            "max_loss": "Strike width - Premium",
        }

    def setup_pin_play(
        self, symbol: str, indicators: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """
        Strategy 4: Weekly expiry pin play (last 3 days before expiry).

        In the last 3 days before options expiry, market makers aggressively
        pin price to max pain. We trade in that direction with high confidence.

        Args:
            symbol: Trading symbol
            indicators: Indicator dictionary with expiry data

        Returns:
            Strategy dictionary or None if not applicable
        """
        # Use real DTE instead of hardcoded 999
        # Calculate days to expiry using ExpiryCalculator
        days_to_expiry = self.expiry_calculator.get_days_to_expiry(symbol)
        
        # Dynamic logic based on real DTE
        if days_to_expiry <= 7:  # Expiry week
            return self._detect_expiry_week_patterns(symbol, indicators)
        else:
            return self._detect_normal_week_patterns(symbol, indicators)

    def iv_crush_play(
        self, symbol: str, indicators: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """
        Strategy 5: Profit from IV collapse after events.

        Before earnings/events, IV spikes to 80%+. After the event, IV
        collapses 30-50%. We sell straddles/strangles to profit from
        IV crush + time decay.

        Args:
            symbol: Trading symbol
            indicators: Indicator dictionary with IV and event data

        Returns:
            Strategy dictionary or None if not applicable
        """
        implied_volatility = indicators.get("implied_volatility", 0)
        event_type = indicators.get("event_type", "")
        event_date = indicators.get("event_date", "")

        # Only trade if IV is extremely high
        if implied_volatility < self.BASE_HIGH_IV_THRESHOLD:
            return None

        # Only trade if there's an upcoming event
        if not event_type:
            return None

        # Determine strategy based on event type
        if event_type == "EARNINGS":
            action = "SELL SHORT STRADDLE"
            expected_iv_drop = 40  # 40% typical IV drop post-earnings
            holding_period = "1 day"
            logic = (
                f"IV CRUSH - EARNINGS: Current IV {implied_volatility}% extremely elevated. "
                f"Post-earnings IV typically drops 30-50%. Sell straddle at-the-money. "
                f"Expected IV drop: {expected_iv_drop}%. Profit from Vega + Theta."
            )

        elif event_type == "FED_MEETING":
            action = "SELL IRON CONDOR"
            expected_iv_drop = 25  # 25% typical IV drop post-Fed
            holding_period = "1-2 days"
            logic = (
                f"IV CRUSH - FED: Current IV {implied_volatility}% elevated before Fed decision. "
                f"Post-decision IV drops 20-30%. Sell iron condor around current price. "
                f"Profit from IV crush + pinning effect."
            )

        elif event_type == "EXPIRY":
            action = "SELL STRANGLE"
            expected_iv_drop = 30  # 30% typical IV drop post-expiry
            holding_period = "Until next expiry"
            logic = (
                f"IV CRUSH - EXPIRY: Weekly expiry approaching. Current IV {implied_volatility}%. "
                f"Post-expiry IV drops 25-35%. Sell strangle out-of-the-money. "
                f"Profit from IV collapse in new cycle."
            )

        else:
            return None

        self.stats["iv_crush_trades"] += 1

        return {
            "strategy_name": "IV_CRUSH_PLAY",
            "strategy_type": "mm_exploitation",
            "symbol": symbol,
            "action": action,
            "direction": "NEUTRAL",
            "confidence": 0.75,
            "implied_volatility": implied_volatility,
            "event_type": event_type,
            "event_date": event_date,
            "expected_iv_drop_pct": expected_iv_drop,
            "logic": logic,
            "risk_level": "HIGH",
            "holding_period": holding_period,
            "profit_source": "Vega (IV drop) + Theta (time decay)",
            "alert_priority": "HIGH",
            "warning": "High risk - event outcome can cause large moves",
        }

    def retail_fade_system(
        self, symbol: str, indicators: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Strategy 6: Automated retail sentiment fade system.

        Continuously monitors social media buzz and retail positioning.
        Generates fade trades when retail is overcrowded on one side.

        Args:
            symbol: Trading symbol
            indicators: Indicator dictionary with sentiment data

        Returns:
            List of fade strategies (can be multiple if multiple conditions met)
        """
        strategies = []

        retail_bullish_ratio = indicators.get("retail_bullish_ratio", 0.5)
        buzz_score = indicators.get("social_media_score", 0.5)
        retail_call_oi = indicators.get("retail_call_oi", 0)
        retail_put_oi = indicators.get("retail_put_oi", 0)

        # Fade extreme retail bullishness
        if buzz_score > self.BASE_SOCIAL_BUZZ_EXTREME:
            if retail_bullish_ratio > self.BASE_RETAIL_BULLISH_EXTREME:
                # Retail overcrowded long
                strategies.append(
                    {
                        "strategy_name": "RETAIL_FADE_SYSTEM_BEARISH",
                        "strategy_type": "mm_exploitation",
                        "symbol": symbol,
                        "action": "SELL CALL CREDIT SPREAD",
                        "direction": "BEARISH",
                        "confidence": 0.85,
                        "sentiment": "FADE_RETAIL_BULLISH",
                        "retail_bullish_ratio": retail_bullish_ratio,
                        "buzz_score": buzz_score,
                        "retail_call_oi": retail_call_oi,
                        "logic": (
                            f"RETAIL FADE: {retail_bullish_ratio:.0%} retail bullish, "
                            f"{buzz_score:.0%} social media buzz. Retail overcrowded LONG. "
                            f"Smart money selling into euphoria. Fade with bearish spread."
                        ),
                        "risk_level": "MEDIUM",
                        "holding_period": "3-7 days",
                        "profit_source": "Retail sentiment reversal",
                        "alert_priority": "VERY HIGH",
                    }
                )
                self.stats["retail_fade_system_trades"] += 1

            elif retail_bullish_ratio < self.BASE_RETAIL_BEARISH_EXTREME:
                # Retail overcrowded short
                strategies.append(
                    {
                        "strategy_name": "RETAIL_FADE_SYSTEM_BULLISH",
                        "strategy_type": "mm_exploitation",
                        "symbol": symbol,
                        "action": "SELL PUT CREDIT SPREAD",
                        "direction": "BULLISH",
                        "confidence": 0.85,
                        "sentiment": "FADE_RETAIL_BEARISH",
                        "retail_bullish_ratio": retail_bullish_ratio,
                        "buzz_score": buzz_score,
                        "retail_put_oi": retail_put_oi,
                        "logic": (
                            f"RETAIL FADE: {retail_bullish_ratio:.0%} retail bullish, "
                            f"{buzz_score:.0%} social media buzz. Retail overcrowded SHORT. "
                            f"Smart money squeezing shorts. Fade with bullish spread."
                        ),
                        "risk_level": "MEDIUM",
                        "holding_period": "3-7 days",
                        "profit_source": "Short squeeze + sentiment reversal",
                        "alert_priority": "VERY HIGH",
                    }
                )
                self.stats["retail_fade_system_trades"] += 1

        return strategies

    def _estimate_strike_increment(self, symbol: str, price: float) -> float:
        """
        Estimate strike increment based on symbol and price.

        Args:
            symbol: Trading symbol
            price: Current price

        Returns:
            Estimated strike increment
        """
        # Ensure symbol is a string (may be int like instrument_token)
        if not isinstance(symbol, str):
            symbol = str(symbol)
        # Index options (NIFTY, BANKNIFTY) have fixed increments
        if "NIFTY" in symbol.upper():
            if "BANK" in symbol.upper():
                return 100  # BANKNIFTY: 100 point increments
            else:
                return 50  # NIFTY: 50 point increments

        # Stock options - estimate based on price
        if price < 500:
            return 10
        elif price < 1000:
            return 20
        elif price < 2000:
            return 50
        else:
            return 100

    def _detect_expiry_week_patterns(self, symbol: str, indicators: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Detect patterns during expiry week (last 7 days)."""
        # Calculate days to expiry using ExpiryCalculator
        days_to_expiry = self.expiry_calculator.get_days_to_expiry(symbol)
        
        # Only trade last 3 days before expiry
        if days_to_expiry > self.DAYS_TO_EXPIRY_PIN_TRADE:
            return None

        max_pain = indicators.get("max_pain_price", 0)
        current_price = indicators.get("last_price", 0)

        if not max_pain or not current_price:
            return None

        # Check if price is far enough from max pain
        distance_pct = abs(max_pain - current_price) / current_price

        if distance_pct < self.MAX_PAIN_DISTANCE_THRESHOLD:
            return None

        # Determine direction
        if current_price > max_pain:
            # Price will be forced DOWN to max pain
            action = "BEAR CALL SPREAD"
            direction = "BEARISH"
            logic = (
                f"PIN PLAY ({days_to_expiry}d to expiry): Price ₹{current_price:.2f} "
                f"above max pain ₹{max_pain:.2f}. MM will force price down to max pain."
            )
        else:
            # Price will be forced UP to max pain
            action = "BULL PUT SPREAD"
            direction = "BULLISH"
            logic = (
                f"PIN PLAY ({days_to_expiry}d to expiry): Price ₹{current_price:.2f} "
                f"below max pain ₹{max_pain:.2f}. MM will force price up to max pain."
            )

        return {
            "action": action,
            "direction": direction,
            "logic": logic,
            "confidence": 0.85,  # High confidence for pin plays
            "days_to_expiry": days_to_expiry,
            "holding_period": f"{days_to_expiry} days (until expiry)",
            "max_pain_distance": distance_pct,
        }

    def _detect_normal_week_patterns(self, symbol: str, indicators: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Detect patterns during normal trading weeks (more than 7 days to expiry)."""
        # For normal weeks, use standard MM trap detection
        # This would include strategies like:
        # - Liquidity grabs
        # - False breakouts
        # - Accumulation/distribution patterns
        # - Support/resistance bounces
        
        # For now, return None to maintain existing behavior
        # In a full implementation, this would contain normal week strategies
        return None

    def get_stats(self) -> Dict[str, int]:
        """Get strategy generation statistics."""
        return dict(self.stats)


# Singleton instance
_mm_exploitation_strategies = None


def get_mm_exploitation_strategies(redis_client=None) -> MMExploitationStrategies:
    """
    Get singleton instance of MM exploitation strategies.

    Args:
        redis_client: Redis client for data access

    Returns:
        MMExploitationStrategies instance
    """
    global _mm_exploitation_strategies
    if _mm_exploitation_strategies is None:
        _mm_exploitation_strategies = MMExploitationStrategies(redis_client)
    return _mm_exploitation_strategies


def generate_mm_exploitation_strategies(
    symbol: str, indicators: Dict[str, Any], trap_result: Dict[str, Any]
) -> List[Dict[str, Any]]:
    """
    Convenience function to generate MM exploitation strategies.

    Args:
        symbol: Trading symbol
        indicators: Complete indicator dictionary
        trap_result: Result from market maker trap detection

    Returns:
        List of strategy dictionaries
    """
    strategies_generator = get_mm_exploitation_strategies()
    return strategies_generator.generate_all_strategies(symbol, indicators, trap_result)


if __name__ == "__main__":
    # Self-test
    print("=" * 80)
    print("MM EXPLOITATION STRATEGIES - Self Test")
    print("=" * 80)

    # Create instance
    strategies = MMExploitationStrategies()

    # Test max pain exploitation
    print("\n1. Testing Max Pain Exploitation:")
    test_indicators = {
        "last_price": 45500.0,
        "max_pain_price": 45000.0,
    }
    result = strategies.max_pain_exploitation("NFO:BANKNIFTY", test_indicators)
    if result:
        print(f"   ✅ Strategy: {result['strategy_name']}")
        print(f"   Action: {result['action']}")
        print(f"   Confidence: {result['confidence']:.0%}")
        print(f"   Logic: {result['logic']}")

    # Test retail sentiment fade
    print("\n2. Testing Retail Sentiment Fade:")
    test_indicators = {
        "retail_bullish_ratio": 0.75,
        "social_media_score": 0.85,
    }
    result = strategies.fade_retail_sentiment("NSE:RELIANCE", test_indicators)
    if result:
        print(f"   ✅ Strategy: {result['strategy_name']}")
        print(f"   Action: {result['action']}")
        print(f"   Confidence: {result['confidence']:.0%}")

    # Test gamma trap
    print("\n3. Testing Gamma Trap Exploitation:")
    test_indicators = {
        "last_price": 19500.0,
        "options_oi_concentration": 0.80,
        "max_pain_strike": 19500.0,
    }
    result = strategies.exploit_gamma_trap("NFO:NIFTY", test_indicators)
    if result:
        print(f"   ✅ Strategy: {result['strategy_name']}")
        print(f"   Action: {result['action']}")
        print(f"   Strikes: {result['strikes']}")

    # Test pin play
    print("\n4. Testing Pin Play:")
    test_indicators = {
        "last_price": 45200.0,
        "max_pain_price": 45000.0,
        "days_to_expiry": 2,
    }
    result = strategies.setup_pin_play("NFO:BANKNIFTY", test_indicators)
    if result:
        print(f"   ✅ Strategy: {result['strategy_name']}")
        print(f"   Action: {result['action']}")
        print(f"   Days to expiry: {result['days_to_expiry']}")
        print(f"   Confidence: {result['confidence']:.0%}")

    # Test IV crush
    print("\n5. Testing IV Crush Play:")
    test_indicators = {
        "implied_volatility": 85,
        "event_type": "EARNINGS",
        "event_date": "2025-01-15",
    }
    result = strategies.iv_crush_play("NSE:TCS", test_indicators)
    if result:
        print(f"   ✅ Strategy: {result['strategy_name']}")
        print(f"   Action: {result['action']}")
        print(f"   Expected IV drop: {result['expected_iv_drop_pct']}%")

    # Test retail fade system
    print("\n6. Testing Retail Fade System:")
    test_indicators = {
        "retail_bullish_ratio": 0.80,
        "social_media_score": 0.90,
        "retail_call_oi": 50000,
    }
    results = strategies.retail_fade_system("NSE:INFY", test_indicators)
    if results:
        print(f"   ✅ Generated {len(results)} fade strategies")
        for r in results:
            print(f"      - {r['action']}: {r['logic'][:80]}...")

    # Print statistics
    print("\n" + "=" * 80)
    print("Statistics:")
    for key, value in strategies.get_stats().items():
        print(f"  {key}: {value}")

    print("\n✅ Self-test complete!")
