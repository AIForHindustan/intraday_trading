#!/usr/bin/env python3
"""
MILLISECOND CRAWLER CONFIGURATION - NIFTY 50 ONLY
================================================
Updated to use millisecond_crawler.json with NIFTY 50 stocks only
Contains 39 NIFTY 50 equity instruments for high-frequency trading
Generated on: 2025-01-20
"""

import json
import os
from pathlib import Path
from typing import Dict, List, Optional

# Configuration constants
MILLISECOND_CRAWLER_VERSION = "2.0.0"
MAX_INSTRUMENTS_PER_BATCH = 500
WEBSOCKET_RECONNECT_DELAY = 3
MEMORY_CLEANUP_INTERVAL = 600  # 10 minutes

# Load instruments from JSON file
def load_millisecond_instruments():
    """
    Load NIFTY 50 instruments from millisecond_crawler.json
    Returns the complete instrument list
    """
    json_file = os.path.join(os.path.dirname(__file__), 'millisecond_crawler.json')
    
    try:
        with open(json_file, 'r') as f:
            data = json.load(f)
        
        print(f"ğŸ“¥ Loaded millisecond_crawler.json")
        print(f"   ğŸ“Š Total instruments: {data['metadata']['total_instruments']}")
        print(f"   ğŸ“Š Asset class: {data['metadata']['asset_class']}")
        print(f"   ğŸ“Š Exchange: {data['metadata']['exchange']}")
        
        return data
    
    except FileNotFoundError:
        print(f"âŒ Error: millisecond_crawler.json not found at {json_file}")
        return None
    except json.JSONDecodeError as e:
        print(f"âŒ Error parsing millisecond_crawler.json: {e}")
        return None
    except Exception as e:
        print(f"âŒ Unexpected error loading millisecond file: {e}")
        return None

def get_millisecond_instruments() -> List[Dict]:
    """
    Get all NIFTY 50 instruments for millisecond crawler
    Returns list of instrument dictionaries with token, symbol, exchange, instrument_type
    """
    data = load_millisecond_instruments()
    if not data:
        return []
    
    instruments = data.get('instruments', [])
    print(f"âœ… Retrieved {len(instruments)} NIFTY 50 instruments")
    return instruments

def get_equity_instruments() -> List[Dict]:
    """Get only equity instruments (all are equity in NIFTY 50)"""
    return get_millisecond_instruments()

def get_instrument_tokens() -> List[int]:
    """
    Get list of instrument tokens for WebSocket subscription
    Returns list of tokens ready for KiteTicker subscription
    """
    instruments = get_millisecond_instruments()
    tokens = [inst['token'] for inst in instruments if 'token' in inst]
    
    print(f"âœ… Extracted {len(tokens)} tokens for WebSocket subscription")
    return tokens

def get_instrument_by_token(token: int) -> Optional[Dict]:
    """
    Get instrument details by token
    Returns instrument dict or None if not found
    """
    instruments = get_millisecond_instruments()
    for inst in instruments:
        if inst.get('token') == token:
            return inst
    return None

def get_instrument_by_symbol(symbol: str) -> Optional[Dict]:
    """
    Get instrument details by symbol
    Returns instrument dict or None if not found
    """
    instruments = get_millisecond_instruments()
    for inst in instruments:
        if inst.get('symbol') == symbol:
            return inst
    return None

def get_token_to_symbol_mapping() -> Dict[int, str]:
    """
    Create mapping from token to symbol for easy lookup
    Returns dict: {token: symbol}
    """
    instruments = get_millisecond_instruments()
    token_mapping = {}
    
    for instrument in instruments:
        token = instrument.get('token')
        symbol = instrument.get('symbol')
        if token and symbol:
            token_mapping[token] = symbol
    
    print(f"âœ… Created token mapping for {len(token_mapping)} instruments")
    return token_mapping

def get_instruments_by_type(instrument_type: str) -> List[Dict]:
    """
    Get instruments by type (EQ, FUT, CE, PE)
    For NIFTY 50, all are EQ type
    """
    instruments = get_millisecond_instruments()
    return [inst for inst in instruments if inst.get('instrument_type') == instrument_type]

def validate_websocket_limits():
    """
    Validate that instruments are within WebSocket limits
    Returns True if within limits, False otherwise
    """
    instruments = get_millisecond_instruments()
    count = len(instruments)
    
    print(f"ğŸ” WebSocket Limit Validation:")
    print(f"   ğŸ“Š Current instruments: {count}")
    print(f"   ğŸ“Š WebSocket limit: {MAX_INSTRUMENTS_PER_BATCH}")
    print(f"   ğŸ“Š Status: {'âœ… OK' if count <= MAX_INSTRUMENTS_PER_BATCH else 'âŒ EXCEEDED'}")
    
    return count <= MAX_INSTRUMENTS_PER_BATCH

def get_crawler_summary():
    """
    Get comprehensive summary of millisecond crawler configuration
    """
    data = load_millisecond_instruments()
    if not data:
        return None
    
    metadata = data.get('metadata', {})
    instruments = data.get('instruments', [])
    
    # Count by exchange
    exchange_counts = {}
    for inst in instruments:
        exchange = inst.get('exchange', 'UNKNOWN')
        exchange_counts[exchange] = exchange_counts.get(exchange, 0) + 1
    
    # Count by instrument type
    type_counts = {}
    for inst in instruments:
        inst_type = inst.get('instrument_type', 'UNKNOWN')
        type_counts[inst_type] = type_counts.get(inst_type, 0) + 1
    
    summary = {
        'total_instruments': len(instruments),
        'metadata': metadata,
        'exchange_breakdown': exchange_counts,
        'type_breakdown': type_counts,
        'websocket_compliant': len(instruments) <= MAX_INSTRUMENTS_PER_BATCH,
        'tokens_available': len([inst for inst in instruments if 'token' in inst])
    }
    
    return summary

# Legacy compatibility - empty dictionaries for backward compatibility
EQUITY_INSTRUMENTS = {}
FNO_INSTRUMENTS = {}
FOCUSED_TOKENS = []

# Export for backward compatibility
__all__ = [
    'get_millisecond_instruments', 'get_equity_instruments', 'get_instrument_tokens',
    'get_instrument_by_token', 'get_instrument_by_symbol', 'get_instruments_by_type',
    'validate_websocket_limits', 'get_crawler_summary',
    'load_millisecond_instruments'
]

# Main execution for testing
if __name__ == "__main__":
    print("ğŸš€ MILLISECOND CRAWLER CONFIGURATION - NIFTY 50 ONLY")
    print("=" * 60)
    
    # Load and validate configuration
    data = load_millisecond_instruments()
    if not data:
        print("âŒ Failed to load configuration")
        exit(1)
    
    # Get summary
    summary = get_crawler_summary()
    if summary:
        print(f"\nğŸ“Š CRAWLER SUMMARY:")
        print(f"   Total Instruments: {summary['total_instruments']}")
        print(f"   WebSocket Compliant: {'âœ… Yes' if summary['websocket_compliant'] else 'âŒ No'}")
        print(f"   Tokens Available: {summary['tokens_available']}")
        
        print(f"\nğŸ“Š BY EXCHANGE:")
        for exchange, count in summary['exchange_breakdown'].items():
            print(f"   {exchange}: {count}")
        
        print(f"\nğŸ“Š BY TYPE:")
        for inst_type, count in summary['type_breakdown'].items():
            print(f"   {inst_type}: {count}")
    
    # Test key functions
    print(f"\nğŸ”§ FUNCTION TESTS:")
    
    # Test instrument loading
    instruments = get_millisecond_instruments()
    print(f"   âœ… Instrument loading: {len(instruments)} instruments")
    
    # Test token extraction
    tokens = get_instrument_tokens()
    print(f"   âœ… Token extraction: {len(tokens)} tokens")
    
    # Test WebSocket validation
    is_valid = validate_websocket_limits()
    print(f"   âœ… WebSocket validation: {'PASS' if is_valid else 'FAIL'}")
    
    # Test individual lookups
    if instruments:
        first_inst = instruments[0]
        symbol = first_inst.get('symbol')
        token = first_inst.get('token')
        
        found_by_symbol = get_instrument_by_symbol(symbol)
        found_by_token = get_instrument_by_token(token)
        
        print(f"   âœ… Symbol lookup: {'PASS' if found_by_symbol else 'FAIL'}")
        print(f"   âœ… Token lookup: {'PASS' if found_by_token else 'FAIL'}")
    
    print(f"\nâœ… NIFTY 50 MILLISECOND CRAWLER READY")
    print(f"   ğŸš€ {len(instruments)} instruments validated and ready for WebSocket subscription")
    print(f"   ğŸ“Š All instruments are NIFTY 50 equity stocks")
    print(f"   ğŸ”§ WebSocket compliant and optimized for high-frequency trading")